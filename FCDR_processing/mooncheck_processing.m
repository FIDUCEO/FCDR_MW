%
 % Copyright (C) 2019-01-04 Imke Hans
 % This code was developed for the EC project ?Fidelity and Uncertainty in   
 %  Climate Data Records from Earth Observations (FIDUCEO)?. 
 % Grant Agreement: 638822
 %  <Version> Reviewed and approved by <name, instituton>, <date>
 %
 %  V 4.1   Reviewed and approved by Imke Hans, Univ. Hamburg, 2019-01-04
 %
 % This program is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the Free
 % Software Foundation; either version 3 of the License, or (at your option)
 % any later version.
 % This program is distributed in the hope that it will be useful, but WITHOUT
 % ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 % FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 % more details.
 % 
 % A copy of the GNU General Public License should have been supplied along
 % with this program; if not, see http://www.gnu.org/licenses/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
%
% mooncheck
%  
%
%



%%%%% read the information on the moon angle from data files created by
%%%%% mhs_cl program and process further (create flags and calculate DSV
%%%%% mean with reduced number of scanlines)
%
 % Copyright (C) 2017-04-12 Imke Hans
 % This code was developed for the EC project ?Fidelity and Uncertainty in   
 %  Climate Data Records from Earth Observations (FIDUCEO)?. 
 % Grant Agreement: 638822
 %  <Version> Reviewed and approved by <name, instituton>, <date>
 %
 %
 %  V 0.1   Reviewed and approved by Imke Hans, Univ. Hamburg, 2017-04-20
 %
 % This program is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the Free
 % Software Foundation; either version 3 of the License, or (at your option)
 % any later version.
 % This program is distributed in the hope that it will be useful, but WITHOUT
 % ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 % FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 % more details.
 % 
 % A copy of the GNU General Public License should have been supplied along
 % with this program; if not, see http://www.gnu.org/licenses/

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this script uses the Run_Length.m function created by Jan
% Simon,Heidelberg, (C) 2013-2017 matlab.2010(a)n(MINUS)simon.de,
% available at https://www.mathworks.com/matlabcentral/fileexchange/41813-runlength
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% info
%
% ONLY USE this script via calling function via generate_FCDR (which calls 
% setup_fullFCDR_uncertproc_MHS, which calls mooncheck).
% DO NOT use this script alone. It needs the output from preceeding
% functions in setup_fullFCDR_uncertproc_MHS.

% Script for setting moonflags and their coding their effect on the
% calibration procedure:
% The script reads the logfile generated by the program mhs_cl for the
% current orbitfile. In the logfile, the minmum angle to the moon is stored
% as well as all contaminated scnalinenumbers along with their contaminated
% views. The script reads out the min-angle and all contaminated
% scanlinenumbers and sets the moon flags according to the scheme explained
% below ("There are 4 cases"). These flags are taken over from the
% envelope-script "setup_fullFCDR..." to compile the final flags.

% The mooncheck script further collects the contaminated views and calculates
% the mean of the DSV counts for the scanline with reduced number of good
% views. This mean (per channel and contaminated scnaline) is taken over by
% the envelope-script "setup_fullFCDR...")


% output: 3 moonflags, DSV-mean values for scanlines with reduced number of
% good views.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% 

% % build filename
% arraychar=char(that_file(selectorbit));
% %ADJUST for AMSUB or MHS on
% if strcmp(arraychar(end-3:end),'.bz2')
%       nameoffile=arraychar(cut:end-4);
% else
%       nameoffile=arraychar(cut:end-3);
% end
% %nameoffile=arraychar(cut:end-3); %FOR AMSUB use cut=25! since two characters more; end-3 to cut .gz
% %logfilename = fullfile(['/scratch/uni/u237/users/ihans/moondata/',sat,'/',num2str(year),'/','mhscl_',nameoffile,'.log']);
% logfilename = fullfile(['/scratch/uni/u237/user_data/mprange/',sat,'/',num2str(year),'/',selectinstrument,'cl_',nameoffile,'.log']);
% %logfilename = fullfile('/scratch/uni/u237/users/ihans/codes/amsubcl_3361112.log');
moon_global_donotuse=zeros(length(scanlinenumbers),1);
flag_moonintrusionfound=0;
indices=[];

% put nameoffile into cell array, especially if only single file used.
if length(hdrinfo.dataset_name)==1
    nameoffile_moon{1}=nameoffile;
else
    nameoffile_moon=nameoffile;
end
    
    for numfil=1:length(hdrinfo.dataset_name)

    logfilename = char(strcat('/scratch/uni/u237/data/fiduceo-fcdr/aux-data/cl_archive_files/',sat,'/',num2str(year),'/',sen,'cl_',nameoffile_moon{numfil},'.log'));  %/scratch/uni/u237/user_data/mprange/


    moonfile=fileread(logfilename);
    positionofMin=strfind(moonfile, 'Min'); %search for 'Min' inidcating minimum moon angle.
    numberofnewlines=strfind(moonfile(1:positionofMin), sprintf('\n')); %count lines until this position of 'Min'
    numberoflinestoskip=length(numberofnewlines); 

    %open logfile created by mhs_cl-program
    fileID = fopen(logfilename);
    %read out Line of file containing minimum angle 
    LineForMinAngle= textscan(fileID,'%s %s %s %s %s %f %f ',1,'HeaderLines',numberoflinestoskip);
    minangle=LineForMinAngle{6}; % read out min angle
    %read out Lines of file containing info for all contaminated scanlines
    %LinesForScanlines=textscan(fileID,'%s %d %s %d %s %s %f ','HeaderLines',5);

    C = textscan(fileID, '%s','Delimiter','');
    C = C{:};
    Lia = ~cellfun(@isempty, strfind(C,'Moon'));
    output = [C{find(Lia)}];
    
        if isempty(output)
            
            %indices(:,i)=[];
            fclose(fileID);
            index_contaminated_lines_vec{numfil}=[];
            contviews_vec{numfil}=[];
        else
            LinesForScanlines=textscan(output,'%s %d %s %d %s %s %f ');
            fclose(fileID);
            
            intermed_scannumbers=LinesForScanlines{2}; % read out all contaminated scannumbers
            scannumbers_vec{numfil}=intermed_scannumbers; 
            
            % Now we have to relate the contaminated lines to the new
            % scanlinenumbering. For this we first have to apply the
            % fill_missing_scanlines-routine. 
            % (Note: scanlinenumbers_original is the numbering AFTER EQ2EQ but BEFORE filling of missinglines, whereas data.orig_scnlinnum contains the true original LEVEL1b scannumbers)
            [~,orig_scnlin_inclmissinglines]=fill_missing_scanlines(double(data.time_EpochSecond)*1000,scanlinenumbers_original,double(data.orig_scnlinnum));
            [~,map_line2l1bfile_inclmissinglines]=fill_missing_scanlines(double(data.time_EpochSecond)*1000,scanlinenumbers_original,double(data.map_line2l1bfile));
            
            % check whether contaminated lines are within the EQ2EQ frame
            % of the underlying l1b file. And get the corresponding
            % relative line numbers in this frame (index_inorigfile)
            scans_for_file=find(map_line2l1bfile_inclmissinglines==(numfil-1)); % find appearances of underlying l1b file in the EQ2EQ frame
            [~,index_inorigfile]=ismember(scannumbers_vec{numfil},orig_scnlin_inclmissinglines(scans_for_file));
            
            % delete all zeros from index_inorigfile (zero means: not a member)
            intrusion_is_member=index_inorigfile~=0; %needed also below to choose corresponding contaminated views
            index_inorigfile=index_inorigfile(intrusion_is_member);
            
            if isempty(index_inorigfile)
                % Moon intrusion is outside of the EQtoEQ frame of the
                % underlying l1b file
                index_contaminated_lines_vec{numfil}=[];
                contviews_vec{numfil}=[];
                flag_moonintrusionfound=1;% is set if any of the used files was contaminated
            else
                %Moon intrusion is within the EQtoEQ frame
                
                %relate the documented contaminated original l1b-scanlines
                %to the new scanline numbering from Eq2Eq file. I.e. add
                %the offset in scanlines due to previous file
                index_firstlineoforigfile=scans_for_file(1);
                index_contaminated_lines_vec{numfil}=index_firstlineoforigfile+index_inorigfile-1;

                % save contaminated views (only for intrusion that are a member(see above): same dimension as index_contaminated_lines_vec)
                intermed_contviews=LinesForScanlines{4};
                contviews_vec{numfil}=intermed_contviews(intrusion_is_member);
                
                flag_moonintrusionfound=1; % is set if any of the used files was contaminated
            end
        end

    
    end
    

% concatenate all found contaminated scanlines       
 scannumbers=vertcat(index_contaminated_lines_vec{:});
 contviews=vertcat(contviews_vec{:});
 
% The variables minangle and scannumbers contain all information for the
% easyFCDR flags.


%%%% set the moon flags

% There are 4 cases:
% 1. Moon is far away from DSV (all moon flags zero)
% 2. Moon close to DSV but not significant (Moonflag1 =1)
% 3. Significant Moon Intrusion in DSV 
%    a) at least one DSV is not contaminated. Calibration carried out with
%    decrease number of DSV. (Moonflag2=1)
%    b) all DSVs are contaminated. Need to take last uncontaminated scan.
%    (Moonflag3=1)
%    


% the moonflagXXX-variables are initialized as zero vectors in the setupt script



if ~isempty(scannumbers) %only if the intermed_scannumbers is NOT empty,
    %we have to look at the individual scanlines to set moonflags
    %If intermed_scannumbers is NOT empty, then minangle<=2.0 (threshold from
    %mhs_cl program).
    % if minangle is smaller than 2.0 degrees, there is high probability that
    % the moon contaminates the signal (increased uncertainty)
    
    
    
    % set the flag for the contaminated scanlines (use variable
    % "scannumbers")
    moonflagSignificantMoonIntrusion(scannumbers)=1; % not used in final set of flags
    
    % How many views are contaminated in each contaminated scanline?
    % count repetitions of scannumber appeareance --> count number of
    % contaminated DSV per scanline
    [contscanlines,numberofviews,indicesInScannumbers]=RunLength_M(scannumbers);
    
    flagperscannumber=int8(floor(numberofviews/4)).'; %generate zeros for 1 to 3 repetitions of scanline (i.e. 1-3 views are contaminated)
    % and generate ones for 4 repetitions, i.e. 4 views are contaminated.
     scnlinallviewsbad=contscanlines(find(flagperscannumber));% takes scanlines for which
    % flagperscannumber is nonzero (here: one)
     scnlinoneviewok=contscanlines(find(~flagperscannumber));% takes scanlines for which
    % flagperscannumber is zero 
    moonflagAllViewsBad(scnlinallviewsbad)=1; %set flag for scanlines for which 4 DSV are contaminated
    moonflagOneViewOk(scnlinoneviewok)=1; % set flag for scanlines for which at least 1 view is ok

    
    % read out contaminated views per scanline
    %intermed_contviews=LinesForScanlines{4};
    %contviews=intermed_contviews;%not true anymore:(1:end-1);
    %contviews
    moonflagwhichviewbad=zeros(length(scanlinenumbers),4);
    allviews=[1 2 3 4];
    for numcontline=1:length(contscanlines)
        contaminatedviews{numcontline}=contviews(indicesInScannumbers(numcontline):indicesInScannumbers(numcontline)+(numberofviews(numcontline)-1));
        intermed_okviews{numcontline}=setdiff(allviews,contaminatedviews{numcontline});
        okviews = intermed_okviews(~cellfun(@isempty, intermed_okviews));
        % construct flag indicating for every scanline and every view, whether
        % it is good=0 or bad=1
        moonflagwhichviewbad(contscanlines(numcontline),contaminatedviews{numcontline})=1;     
    end
    
    
    
    for numokline=1:length(scnlinoneviewok)
        meandsvch1okviews(numokline)=        mean(dsvch1(scnlinoneviewok(numokline),okviews{numokline}),2);
        meandsvch2okviews(numokline)=        mean(dsvch2(scnlinoneviewok(numokline),okviews{numokline}),2);
        meandsvch3okviews(numokline)=        mean(dsvch3(scnlinoneviewok(numokline),okviews{numokline}),2);
        meandsvch4okviews(numokline)=        mean(dsvch4(scnlinoneviewok(numokline),okviews{numokline}),2);
        meandsvch5okviews(numokline)=        mean(dsvch5(scnlinoneviewok(numokline),okviews{numokline}),2);
    end
    
else

    scnlinallviewsbad=[];
    scnlinoneviewok=[];
    
    
    if minangle<=2.0 && flag_moonintrusionfound==0
    disp('Error. Moon intrusion somewhere in the orbit probable, but not documented for scanlines in logfile. Do not use any scanline.')
    moon_global_donotuse=ones(length(scanlinenumbers),1);
    elseif minangle<=2.0 && flag_moonintrusionfound==1
    disp('Moon intrusion happens outside the Equator-to-Equator frame. No influence on calibration of this file.')
    
    elseif 2.0< minangle && minangle<2.5
    % if minangle is larger than 2.0 degrees but smaller than 2.5, we say that
    % there is little chance that the moon contaminates the signal (slightly
    % increased uncertainty) somewhere in the orbit
    
    moonflagMoonCloserButNotSignificant=ones(length(scanlinenumbers),1); %set flag to 1 for all scanlines
    
    % if minangle is larger than 2.5 degrees, we say we are on the safe side
    % that the moon is NOT in the DSV (NO increased uncertainty): NO FLAG!!
    end
    
    
end

